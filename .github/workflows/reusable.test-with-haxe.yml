# SPDX-FileCopyrightText: Â© Vegard IT GmbH (https://vegardit.com) and contributors
# SPDX-FileContributor: Sebastian Thomschke, Vegard IT GmbH
# SPDX-License-Identifier: Apache-2.0
#
# https://docs.github.com/en/actions/creating-actions/creating-a-composite-action
name: Test with Haxe
on:
  workflow_call:
    inputs:
      runner-os:    { required: true,        type: string, description: "e.g. ubuntu-latest, macos-latest, windows-latest" }
      haxe-version: { required: true,        type: string, description: "Haxe version to test with" }
      haxe-libs:    { required: false,       type: string, description: "Haxe libs to install via haxelib command separated by space, e.g. 'hscript format@1.0.0'" }
      haxe-args:    { default: "tests.hxml", type: string, description: "default .hxml file to use" }
      output-dir:   { default: "target",     type: string, description: "output folder for compilation artifacts"}

      test-cpp:    { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-cs:     { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-eval:   { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-flash:  { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-hl:     { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-java:   { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-jvm:    { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-lua:    { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-neko:   { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-node:   { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-php:    { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }
      test-python: { default: "false", type: string, description: "To enable specify 'true' or the path to a .hxml file" }

      continue-on-error: { required: false, type: string, description: "A space or comma separated list of haxe targets which are allowed to fail" }
      retries:           { default:  0, type: number, description: "Number of test retries in case of failures" }
      
      timeout-minutes-test: { default: 10, type: number, description: "The maximum number of minutes a test can run before it is terminated." }
      timeout-minutes:      { default: 60, type: number, description: "The maximum number of minutes the build job shall run." }

      before-tests:       { required: false, type: string, description: "a bash script to be executed before the first test" }
      #before-tests-shell: { default: "bash", type: string, description: "shell to be used to esecute the before-tests script" }
      after-tests:        { required: false, type: string, description: "a bash script to be executed after the last test" }
      #after-tests-shell:  { default: "bash", type: string, description: "shell to be used to esecute the after-tests script" }

      debug-with-ssh:                    { default: "never", type: string,  description: "Start an SSH session for debugging purposes after tests ran: never, always, on_failure, on_failure_or_cancelled" }
      debug-with-ssh-only-for-actor:     { default: true,    type: boolean, description: "Limit access to the SSH session to the GitHub user that triggered the job" }
      debug-with-ssh-only-jobs-matching: { default: ".*",    type: string,  description: "Only start an SSH session for jobs matching this regex pattern" }

      # only needs to be specified when executed with nektos/act:
      haxe-reusable-workflows-repo:    { default: "vegardit/haxe-reusable-workflows", type: string, description: "Repository containing this workflow" }
      haxe-reusable-workflows-version: { default: "v1",                               type: string, description: "Version of this workflow" }

defaults:
  run:
    shell: bash

jobs:
  test-with-haxe:
    runs-on: ${{ inputs.runner-os }}
    timeout-minutes: ${{ inputs.timeout-minutes }}
    permissions:
      id-token: write # currently required to determine job_workflow_ref / job_workflow_sha

    steps:
    - name: Process input parameter
      run: |
        # Convert inputs that can be passed as boolean or string to strings so we can do
        # {{ env.TEST_CPP == 'true' }} instead of {{ inputs.test-cpp == 'true' || inputs.test-cpp == true }}
        cat <<EOF >> $GITHUB_ENV
        TEST_CPP=${{    inputs.test-cpp }}
        TEST_CS=${{     inputs.test-cs }}
        TEST_EVAL=${{   inputs.test-eval }}
        TEST_FLASH=${{  inputs.test-flash }}
        TEST_HL=${{     inputs.test-hl }}
        TEST_JAVA=${{   inputs.test-java }}
        TEST_JVM=${{    inputs.test-jvm }}
        TEST_LUA=${{    inputs.test-lua }}
        TEST_NEKO=${{   inputs.test-neko }}
        TEST_NODE=${{   inputs.test-node }}
        TEST_PHP=${{    inputs.test-php }}
        TEST_PYTHON=${{ inputs.test-python }}
        EOF

        cat <<EOF >> $GITHUB_ENV
        TEST_CPP_CONTINUE_ON_ERROR=$(    [[ "${{ inputs.continue-on-error }}" == *cpp*    ]] && echo "true" || : )
        TEST_CS_CONTINUE_ON_ERROR=$(     [[ "${{ inputs.continue-on-error }}" == *cs*     ]] && echo "true" || : )
        TEST_EVAL_CONTINUE_ON_ERROR=$(   [[ "${{ inputs.continue-on-error }}" == *eval*   ]] && echo "true" || : )
        TEST_FLASH_CONTINUE_ON_ERROR=$(  [[ "${{ inputs.continue-on-error }}" == *flash*  ]] && echo "true" || : )
        TEST_HL_CONTINUE_ON_ERROR=$(     [[ "${{ inputs.continue-on-error }}" == *hl*     ]] && echo "true" || : )
        TEST_JAVA_CONTINUE_ON_ERROR=$(   [[ "${{ inputs.continue-on-error }}" == *java*   ]] && echo "true" || : )
        TEST_JVM_CONTINUE_ON_ERROR=$(    [[ "${{ inputs.continue-on-error }}" == *jvm*    ]] && echo "true" || : )
        TEST_LUA_CONTINUE_ON_ERROR=$(    [[ "${{ inputs.continue-on-error }}" == *lua*    ]] && echo "true" || : )
        TEST_NEKO_CONTINUE_ON_ERROR=$(   [[ "${{ inputs.continue-on-error }}" == *neko*   ]] && echo "true" || : )
        TEST_NODE_CONTINUE_ON_ERROR=$(   [[ "${{ inputs.continue-on-error }}" == *node*   ]] && echo "true" || : )
        TEST_PHP_CONTINUE_ON_ERROR=$(    [[ "${{ inputs.continue-on-error }}" == *php*    ]] && echo "true" || : )
        TEST_PYTHON_CONTINUE_ON_ERROR=$( [[ "${{ inputs.continue-on-error }}" == *python* ]] && echo "true" || : )
        EOF

    - name: Show environment variables
      run: env | sort

    - name: Git Checkout
      uses: actions/checkout@v3 #https://github.com/actions/checkout

    ##################################################
    # Cache Restore
    # See https://github.com/actions/cache/issues/342
    ##################################################
    - name: "Haxe Libs Cache: Restore"
      id: HAXE-LIBS-CACHE-RESTORE
      if: ${{ !env.ACT }} # https://github.com/nektos/act#skipping-steps
      uses: actions/cache/restore@v3 # https://github.com/actions/cache/tree/main/restore
      with:
        path: |
          ${{ runner.tool_cache }}/haxe/lib
          ${{ runner.tool_cache }}/jq
        key: ${{ runner.os }}-haxelibs-${{ inputs.haxe-version }}

    - name: "Haxe Libs Cache: Init Root Path"
      id: HAXE-TARGETS-CACHE
      run: |
        set -euo pipefail

        if [[ "${{ runner.os }}" == "Windows" ]]; then
          path_nix="$(cygpath '${{ runner.tool_cache }}')/haxe/lib"
          echo 'path_win=${{ runner.tool_cache }}\haxe\lib' | tee -a "$GITHUB_OUTPUT"
        else
          path_nix="${{ runner.tool_cache }}/haxe/lib"
        fi
        mkdir -p "$path_nix"
        echo "path_nix=$path_nix" | tee -a "$GITHUB_OUTPUT"

        pushd "$path_nix"
          # create a quick hashsum based on file names and file size
          case "${{ runner.os }}" in
            macOS) echo "initial_hash=$(find . -type f -print0 | xargs -0r stat -f '%N %z' | sort -z | shasum  | cut -d' ' -f1)" | tee -a "$GITHUB_OUTPUT" ;;
            *)     echo "initial_hash=$(find . -type f -printf "%p %s\n" | sort -z | sha1sum | cut -d' ' -f1)" | tee -a "$GITHUB_OUTPUT" ;;
          esac
        popd

        ls -l $path_nix


    ##################################################
    # Install software
    ##################################################
    - name: "Install: jq" # https://github.com/stedolan/jq
      run: |
        set -euo pipefail

        if ! hash jq 2>/dev/null; then
          case "${{ runner.os }}" in
            Linux)
              jqHome="${{ runner.tool_cache }}/jq"
              jq_source_exe="jq-linux64"
              jq_target_exe=jq
              ;;
            macOS)
              jqHome="${{ runner.tool_cache }}/jq"
              jq_source_exe="jq-osx.amd64"
              jq_target_exe=jq
              ;;
            Windows)
              jqHome="$(cygpath '${{ runner.tool_cache }}')/jq"
              jq_source_exe="jq-win64.exe"
              jq_target_exe=jq.exe
              ;;
          esac
          if [[ ! -f $jqHome/$jq_target_exe ]]; then
            jq_version=$(curl -sSfL -o /dev/null -w "%{url_effective}\n" https://github.com/stedolan/jq/releases/latest | grep -o '[^/]*$')
            jq_download_url="https://github.com/stedolan/jq/releases/download/$jq_version/$jq_source_exe"
            echo "Downloading [$jq_download_url]..."
            mkdir -p $jqHome
            curl -fsSL --retry 3 --retry-delay 5 -o $jqHome/$jq_target_exe "$jq_download_url"
          fi
          chmod 777 $jqHome/$jq_target_exe
          echo '${{ runner.tool_cache }}/jq' >> $GITHUB_PATH
        fi

    - name: "Verify: jq"
      run: jq --version


    # workaround to determine job_workflow_ref / job_workflow_sha to run the 'setup-haxe-targets' action from the same branch as the reusable workflow
    # - https://stackoverflow.com/questions/71046096/reusable-workflows-with-local-actions
    # - https://github.com/community/community/discussions/31054
    - name: "Determine reusable workflow repo"
      id: job_workflow_info
      run: |
        # nektos/act does not provide $ACTIONS_ID_TOKEN_REQUEST_TOKEN so we need a workaround for the workaround
        if [[ "${{ env.ACT }}" == "true" ]]; then
          # checkout "actions/checkout@v3" fails with "using ::error::Input required and not supplied: token"
          # thus we do it old school
          rm -rf ./.github/haxe-reusable-workflows
          git clone "https://github.com/${{ inputs.haxe-reusable-workflows-repo }}" \
             --depth 1 --single-branch \
             -b "${{ inputs.haxe-reusable-workflows-version }}" \
             ./.github/haxe-reusable-workflows
        else
          id_token_payload=$(jq -R 'split(".") | .[1] | @base64d | fromjson' <<< "$ACTIONS_ID_TOKEN_REQUEST_TOKEN")
          echo "repo=$(jq -r '.oidc_extra | fromjson | .job_workflow_ref | split("/")[0:2] | join("/")' <<< $id_token_payload)" >> $GITHUB_OUTPUT
          echo  "ref=$(jq -r ".oidc_extra | fromjson | .job_workflow_sha" <<< $id_token_payload)" >> $GITHUB_OUTPUT
        fi
    - name: "Git checkout workflow repo"
      if: ${{ !env.ACT }}
      uses: actions/checkout@v3
      with:
        path: ./.github/haxe-reusable-workflows
        repository: ${{ steps.job_workflow_info.outputs.repo }}
        ref: ${{ steps.job_workflow_info.outputs.ref }}


    - name: "Setup: Haxe with Targets"
      id: setup-haxe-targets
      uses: ./.github/haxe-reusable-workflows/.github/actions/setup-haxe-targets
      with:
        setup-cpp:    ${{ env.TEST_CPP    != 'false' }}
        setup-cs:     ${{ env.TEST_CS     != 'false' }}
        setup-flash:  ${{ env.TEST_FLASH  != 'false' }}
        setup-hl:     ${{ env.TEST_HL     != 'false' }}
        setup-java:   ${{ env.TEST_JAVA   != 'false' || env.TEST_JVM != 'false' }}
        setup-lua:    ${{ env.TEST_LUA    != 'false' }}
        setup-node:   ${{ env.TEST_NODE   != 'false' }}
        setup-php:    ${{ env.TEST_PHP    == 'true' && startsWith(inputs.haxe-version, '3.') && '5.6' || env.TEST_PHP != 'false' }}
        setup-python: ${{ env.TEST_PYTHON != 'false' }}

    - name: "Install: Haxe ${{ matrix.haxe }}"
      uses: krdlab/setup-haxe@v1 # https://github.com/krdlab/setup-haxe
      with:
        haxe-version: ${{ inputs.haxe-version }}

    - name: "Verify: Haxe"
      run: haxe -version # haxe 3 only supports -version. haxe 4 also --version

    - name: "Install: Haxe Libraries"
      run: |
        set -euo pipefail

        case "${{runner.os}}" in
          Windows)
            export HAXELIB_PATH="${{ runner.tool_cache }}\\haxe\\lib"
            mkdir -p "$(cygpath "$HAXELIB_PATH")"
            ;;
          *)
            export HAXELIB_PATH="${{ runner.tool_cache }}/haxe/lib"
            mkdir -p "$HAXELIB_PATH"
            ;;
        esac
        echo "HAXELIB_PATH=$HAXELIB_PATH" >> $GITHUB_ENV

        haxelib config

        haxelibs="${{ inputs.haxe-libs }}"
        if [[ $TEST_CPP  == "true" ]]; then haxelibs+=" hxcpp"; fi
        if [[ $TEST_CS   == "true" ]]; then haxelibs+=" hxcs"; fi
        if [[ $TEST_JAVA == "true" || $TEST_JVM == "true" ]]; then 
          if [[ "${{ inputs.haxe-version }}" == 3.* ]]; then
            haxelibs+=" hxjava@3.2.0"
          else
            haxelibs+=" hxjava"
          fi
        fi
        if [[ $TEST_NODE == "true" ]]; then haxelibs+=" hxnodejs"; fi

        if [[ -n "$haxelibs" ]]; then
          for lib in $haxelibs; do
            echo "::group::install_$lib"
            lib_name="${lib%%@*}"
            lib_ver="$(echo $lib | cut -s -d@ -f2)"
            # for loops are to mitigate possible HTTP connection timeouts
            if [[ -n $lib_ver ]]; then
              for i in {1..3}; do haxelib --always install $lib_name $lib_ver && break || sleep 2; done
              haxelib --always set $lib_name $lib_ver
            else
              for i in {1..3}; do haxelib --always install $lib_name && break || sleep 2; done
              for i in {1..3}; do haxelib --always update $lib_name && break  || sleep 2; done
            fi
            echo "::endgroup::"
          done
        fi

        if [[ -f haxelib.json ]]; then
          haxelib dev $(jq -r .name haxelib.json) .
        fi

    - name: Create output dir '${{ inputs.output-dir }}'
      run: mkdir -p "${{ inputs.output-dir }}"


    ##################################################
    # Cache Update
    # See https://github.com/actions/cache/issues/342
    ##################################################
    - name: "Haxe Libs Cache: Prepare Update"
      id: HAXE-LIBS-CACHE-UPDATE-PREPARE
      if: ${{ !env.ACT }}
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail
        if [[ "${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-hit }}" == "true" ]]; then

          pushd "${{ steps.haxe-targets.cache.outputs.path_nix }}"
            # create a quick hashsum based on file names and file size
            case "${{ runner.os }}" in
              macOS) current_hash="$(find . -type f -print0 | xargs -0r stat -f '%N %z' | sort -z | shasum  | cut -d' ' -f1)" ;;
              *)     current_hash="$(find . -type f -printf "%p %s\n" | sort -z | sha1sum | cut -d' ' -f1)" ;;
            esac
          popd

          if [[ "$current_hash" != "${{ steps.haxe-targets.cache.outputs.initial_hash }}" ]]; then
            echo "Cache update needed, since folder content changed. new hash: $current_hash"

            primaryCacheKey="${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-primary-key }}"
            matchedCacheKey="${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-matched-key }}"
            if [[ $primaryCacheKey == "$matchedCacheKey" ]]; then
              gh extension install actions/gh-actions-cache || true
              if gh actions-cache delete "$primaryCacheKey" --confirm; then
                echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"                  
              fi
            else
              echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"
            fi
          else
            echo "No Cache update needed"
          fi
        else
          echo "Cache update needed, since no cache hit occured"
          echo "need_cache_update=true" | tee -a "$GITHUB_OUTPUT"
        fi

    - name: "Haxe Libs Cache: Update"
      uses: actions/cache/save@v3
      if: ${{ steps.HAXE-LIBS-CACHE-UPDATE-PREPARE.outputs.need_cache_update }}
      with:
        path: |
          ${{ runner.tool_cache }}/haxe/lib
          ${{ runner.tool_cache }}/jq
        key: ${{ steps.HAXE-LIBS-CACHE-RESTORE.outputs.cache-primary-key }}

    - name: "Before Tests: Custom Bash script"
      if: ${{ inputs.before-tests }}
      #shell: ${{ inputs.before-tests-shell }}
      env:
        GITHUB_JOB_ID: ${{ github.job }}
      run: ${{ inputs.before-tests }}


    ##################################################
    # Tests
    ##################################################
    - name: Show environment variables
      run: env | sort


    - name: Test [neko]
      if: ${{ env.TEST_NEKO != 'false' }}
      continue-on-error: ${{ env.TEST_NEKO_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run:  |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_NEKO != "true" ]] && hxmlFile=$TEST_NEKO || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -neko ${{ inputs.output-dir }}/tests.n

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          neko ${{ inputs.output-dir }}/tests.n && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [hl]
      if: ${{ env.TEST_HL != 'false' }}
      continue-on-error: ${{ env.TEST_HL_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_HL != "true" ]] && hxmlFile=$TEST_HL || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -hl ${{ inputs.output-dir }}/tests.hl

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          hl ${{ inputs.output-dir }}/tests.hl && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [eval]
      if: ${{ env.TEST_EVAL != 'false' }}
      continue-on-error: ${{ env.TEST_EVAL_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_EVAL != "true" ]] && hxmlFile=$TEST_EVAL || hxmlFile="${{ inputs.haxe-args }}"

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          haxe $hxmlFile -D eval-stack --interp && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [flash]
      if: ${{ env.TEST_FLASH != 'false' }}
      continue-on-error: ${{ env.TEST_FLASH_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_FLASH != "true" ]] && hxmlFile=$TEST_FLASH || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -swf ${{ inputs.output-dir }}/tests.swf

        # workaround for random "Application crashed with an unhandled SIGSEGV"
        max_attempts=10
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          rm -f ${{ steps.setup-haxe-targets.outputs.flash-log }}
          tail --follow=name --retry "${{ steps.setup-haxe-targets.outputs.flash-log }}" 2>/dev/null &
          "${{ steps.setup-haxe-targets.outputs.flash-cmd }}" "${{ inputs.output-dir }}/tests.swf" && exit_code=0 || exit_code=$?
          ps aux | grep "[t]ail --follow=name --retry" | awk '{print $2}' | xargs kill -9 2>/dev/null || true
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [java]
      if: ${{ env.TEST_JAVA != 'false' }}
      continue-on-error: ${{ env.TEST_JAVA_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_JAVA != "true" ]] && hxmlFile=$TEST_JAVA || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -java ${{ inputs.output-dir }}

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          java -jar ${{ inputs.output-dir }}/*.jar && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [jvm]
      if: ${{ env.TEST_JVM != 'false' }}
      continue-on-error: ${{ env.TEST_JVM_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_JVM != "true" ]] && hxmlFile=$TEST_JVM || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -D jvm -java ${{ inputs.output-dir }}

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          java -jar ${{ inputs.output-dir }}/*.jar && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [lua]
      if: ${{ env.TEST_LUA != 'false' }}
      continue-on-error: ${{ env.TEST_LUA_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_LUA != "true" ]] && hxmlFile=$TEST_LUA || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -lua ${{ inputs.output-dir }}/tests.lua

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          lua ${{ inputs.output-dir }}/tests.lua && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [node]
      if: ${{ env.TEST_NODE != 'false' }}
      continue-on-error: ${{ env.TEST_NODE_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_NODE != "true" ]] && hxmlFile=$TEST_NODE || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -lib hxnodejs -D nodejs -js ${{ inputs.output-dir }}/tests.js

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          node ${{ inputs.output-dir }}/tests.js && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [php]
      if: ${{ env.TEST_PHP != 'false' }}
      continue-on-error: ${{ env.TEST_PHP_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_PHP != "true" ]] && hxmlFile=$TEST_PHP || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -php ${{ inputs.output-dir }}/php

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          php ${{ inputs.output-dir }}/php/index.php && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [python]
      if: ${{ env.TEST_PYTHON != 'false' }}
      continue-on-error: ${{ env.TEST_PYTHON_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_PYTHON != "true" ]] && hxmlFile=$TEST_PYTHON || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -python ${{ inputs.output-dir }}/tests.py

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          python ${{ inputs.output-dir }}/tests.py && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [cs]
      if: ${{ env.TEST_CS != 'false' }}
      continue-on-error: ${{ env.TEST_CS_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_CS != "true" ]] && hxmlFile=$TEST_CS || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -cs ${{ inputs.output-dir }}/cs

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          mono ${{ inputs.output-dir }}/cs/bin/*.exe && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: Test [cpp] # testing C++ as last since it takes the longest to build
      if: ${{ env.TEST_CPP != 'false' }}
      continue-on-error: ${{ env.TEST_CPP_CONTINUE_ON_ERROR == 'true' }}
      timeout-minutes: ${{ inputs.timeout-minutes-test }}
      run: |
        set -eux
        rm -rf ${{ inputs.output-dir }}/*
        [[ $TEST_CPP != "true" ]] && hxmlFile=$TEST_CPP || hxmlFile="${{ inputs.haxe-args }}"
        haxe $hxmlFile -cpp ${{ inputs.output-dir }}/cpp
        if [[ $OSTYPE == "darwin"* ]]; then
          executableFilterFlag="-perm +111"
        else
          executableFilterFlag="-executable"
        fi

        max_attempts=$((1 + ${{ inputs.retries }}))
        for i in $(seq 1 $max_attempts); do
          echo -e "$i. of $max_attempts attempt(s)...\n====================="
          $(find ${{ inputs.output-dir }}/cpp -maxdepth 1 $executableFilterFlag -type f) && exit_code=0 || exit_code=$?
          if [[ $exit_code -eq 0 ]]; then break;
          elif [[ $i -eq $max_attempts ]]; then exit $exit_code;
          else sleep 5; fi
        done

    - name: "After Tests: Custom Bash script"
      if: ${{ always() && inputs.after-tests }}
      #shell: ${{ inputs.after-tests-shell }}
      env:
        GITHUB_JOB_ID: ${{ github.job }}
        GITHUB_JOB_STATUS: ${{ job.status }}
      run: ${{ inputs.after-tests }}

    - name: "SSH session for debugging: check"
      id: debug_ssh_sesssion_check
      if: always()
      run: |
        set -eu
        job_filter_pattern="${{ inputs.debug-with-ssh-only-jobs-matching }}"
        echo "job_filter: $job_filter_pattern"

        job_info=$(echo "$GITHUB_JOB ${{ toJSON(matrix) }}" | tr -d '\n')
        echo "job_info: $job_info"

        if [[ "$job_info" =~ .*$job_filter_pattern.* ]] && case "${{ job.status }}" in
           success)   [[ "${{ inputs.debug-with-ssh }}" == always ]] ;;
           cancelled) [[ "${{ inputs.debug-with-ssh }}" == on_failure_or_cancelled ]] ;;
           failure)   [[ "${{ inputs.debug-with-ssh }}" =~ on_failure.* ]] ;;
        esac; then
           echo "start_session=true" >>$GITHUB_OUTPUT;
        fi

    - name: "SSH session for debugging: start"
      uses: mxschmitt/action-tmate@v3 # https://github.com/mxschmitt/action-tmate
      if: always() && steps.debug_ssh_sesssion_check.outputs.start_session
      with:
        limit-access-to-actor: ${{ inputs.debug-with-ssh-only-for-actor }}
